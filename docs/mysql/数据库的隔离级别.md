## 事务的属性

事务必须满足四个属性，即原子性（Atomcity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），即ACID四种属性。

1. 原子性

   一个事务是一个不可分割的整体，为了保证事务的总体目标，事务必须具有原子性，即当数据修改时，要么全都执行，要么全都不执行。即，不允许事务部分地完成，避免了只执行这些操作的一部分而带来的错误。

2. 一致性

   一个事务在执行之前和执行之后，数据库数据必须保持一致性。数据库的一致性状态应该满足模式锁指定的约束条件，那么在完整执行该事务后，数据库仍然处于一致性状态。

   **例如：**银行转账，转账前后两个账户金额之和应保持不变。

3. 隔离性

   由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据库时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。

   例如：对任何一对事务T1和T2，对T1而言，T2要么在T1开始之前已经结束，要么在T1完成之后再开始执行。

4. 持久性

   也被称为永久性，事务完成以后，DBMS（数据库管理系统）保证它对数据库中数据的修改是永久性的，当系统或介质发生故障时，该修改也永久保持。持久性一般通过数据库备份与恢复来保证。

## 并发控制

1. DBS（数据库系统）一个明显的特点是**多个用户共享数据库资源**，尤其是多个用户可以同时存取相同数据。

   - **串行控制**：如果事务是顺序执行的，即一个事务完成之后，再开始另一事务。
   - **并行控制**：如果DBMS可以同时接受多个事务，并且这些事务在时间上可以重叠执行。

2. 并发控制概述

   **事务是并发控制的基本单位**，保证事务ACID的特性是事务处理的重要任务，而并发操作有可能会破坏其ACID特性。

   **DBMS并发控制机制的责任**：对并发操作进行正确调度，保证事务的隔离更一般，确保数据库的一致性。

## 由于并发操作带来的数据不一致性









## 事务的隔离级别

为了避免上面出现的几种情况，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。

- **读未提交（Read Uncommitted）**

  读未提交，顾名思义，就是可以读到未提交的内容。

  因此，在这种隔离级别下，查询是不会加锁的，也由于查询的不加锁，所以这种隔离级别的一致性是最差的，可能会产生**“脏读”、“不可重复读”、“幻读”**。

  如无特殊情况，基本是不会使用这种隔离级别的。

- **读提交（Read Committed）**

  读提交，顾名思义，就是只能读到已经提交了的内容。

  这是各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。这种隔离级别能够有效的避免脏读，但除非在查询中显示的加锁，如：

  ```sql
  #加上共享锁
  select * from T where ID=2 lock in share mode;
  
  #加上排他锁
  select * from T where ID=2 for update;
  ```

  不然，普通的查询是不会加锁的。

  那为什么“读提交”同“读未提交”一样，都没有查询加锁，但是却能够避免脏读呢？

  这就要说道另一个机制“快照（snapshot）”，而这种既能保证一致性又不加锁的读也被称为“**快照读（Snapshot Read）**”

  假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞，这种情况下，并发能力就相当的差。

  而“快照读”就可以完成高并发的查询，不过，**“读提交”只能避免“脏读”，并不能避免“不可重复读”和“幻读”**。

- **可重复读取（Repeatable Read）**

  可重复读，顾名思义，就是专门针对“不可重复读”这种情况而制定的隔离级别，自然，它就可以有效的避免“不可重复读”。而它也是MySql的默认隔离级别。

  在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时，就不允许进行“修改操作（Update）”了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，**“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”**，因为幻读是由于“插入或者删除操作（Insert or Delete）”而产生的。

- **串行化（Serializable）**

  这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行。

  这种级别下，“脏读”、“不可重复读”、“幻读”都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。





脏读：“select”操作没有规矩，会查询到未提交的事务。

不可重复读：“update”操作没有规矩，两次查询到的数据不一样

幻读：“insert”操作没有规矩，两次查询到的数据条数不一样

